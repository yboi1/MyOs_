## 第七章 (中断):

​    添加文件    (interrupt, global, io, timer)

​    修改文件    (kernel.S)

- ​     实现了中断向量表idt 产生异常后会提示异常号, 根据异常号可以定位错误处 主要是通过完善了loader中, 将处理异常的地址放到table中,通过kernel.S调用实现中断处理
- ​    实现了可编程计数器 timer 通过内联汇编产生时钟中断
-    io.h 用于操作硬盘或者显卡, 对端口进行读写
-    init 实现中断表的初始化
-    global   将idt中断描述符封装为宏 

## 第八章 (内存管理系统): 

​    添加文件    (debug, memory, bitmap, string)

- MakeFile编写 实现项目的一键编译, 摆脱了sh文件的依赖, 想要用cmakefile配合clangd使用, 但是cmakefile报错无法找到头文件, 不知道什么原因
- 实现ASSERT c 语言中常常使用ASSERT, 但本质就是一个if判断而已, 调用了自己的debug函数, 实现对错误信息的打印, 方便了调试
- 实现string函数 编写自己的string库, 方便了对字符串的处理 
- 实现bitmap数据结构, 本章主要作用是为了服务内存是否使用, 通过scan和set函数可以实现对位图操作,表示内存是否被占用 及 标记为 已占用 (因为遍历内存的变量写错,debug了半天)
- 实现memory函数   本质就是实现了malloc, 传入页表数即可返回分配好的地址 主要涉及的操作是得到虚拟内存地址和物理内存地址, 并将两个地址映射 实现虚拟内存管理, 于前面的机制相匹配


## 第九章 (进程):

​    添加文件    (thread, list, switch)

- 进程和线程的区别 线程=具有能动性,独立性,执行力的代码块  进程=资源+线程   执行单元都是线程, 根据进程中包含线程的个数区分是单线程程序还是多线程程序    进程独自拥有整个地址空间,在这个空间装有一切线程所需的资源   执行流,调度实体,运行实体等概念都是针对线程而言,只有它能上处理器运行, 即一切执行流其实都是线程

-   PCB 保存线程的信息

- 内核/用户进程实现线程, 内核更为方便, 方便线程切换及阻塞等功能

- 调度器, 初步实现多线程, 但是会出现越界的错误, 未解决!!!

- 通过长时间debug找到原因是因为 set_cursor(0) 错误, ret时他的返回地址给的是0 目前注释掉以后程序正常

## 第十章 (输入输出系统)

​    添加文件    (console, keyboard, sync, ioqueue)

- 实现锁结构, 保证原子操作安全 使用的是信号量模型
- 实现keyboard文件, 为键盘进行注册, 通过键盘扫描码得到对应的ascii码, 并根据不同的组合键实现不同的功能
-  实现console文件 实现键盘驱动程序, 通过键盘中断实现键盘的读入界面
- 实现ioqueue 循环队列, 实现生产者消费者模型, 中断事件为生产者, shell 为消费者 为后续实现人机交互提供基础
- 中断个数增加, 由原本的21个中断 添加到了30个, 并进行了注册
- 为了找上一章set_cursor产生的bug, 又一次学习了bochs的调试技巧, 有了不小的收获-希望能类比到gdb去





## 第十一章(用户进程)



- 实现tss结构 主要是规定的规则, 无脑cv过来的, 但是由于我自己的地址是903 所以在init处需要另外修改, 否则无法正常创建出tss页表 主要是为了后续的用户进程做铺垫
- 



## 简单调试:

找到函数对应的地址: nm build/kernel.bin | grep thread_start

- ~设置断点:   lb 0xc0002e50  -vb +虚拟地址    -lb +线性地址  -pb +物理地址
  - ​            -sb [delta] delta表示增量, 再执行多少条指令中断  sba -> 第多少条指令中断
- ~查看断点:   info b      可以得到断点的num  
- ~删除断点:   d num 
- 00017865031: exception (not softint) 0008:c0001d1a (0xc0001d1a)

- ~设置时间点断点:  sba 00017865030       17865067
- ~查看当前总共执行了多少条指令:  ptime
- ~查看内存: x +线性内存  xp +物理内存
- ~反汇编指令: u/1 0xc0002019 
- ~变换模式时提示: show mode
- ~中断提示:  show int    -show softint 软件主动触发的中断    -show extint 显示外部设备中断   
-  -show iret 只显示iretd指令有关的信息
- ~函数调用提示:  show call
- ~显示汇编代码:   traceon\off 每条指令都显示
- ~显示堆栈:  print-stack [num]   num默认16 表示打印的数目
- ~显示状态寄存器:    r